## Документация по шаблонизатору Excel (pkg/excel)

Новый шаблонизатор поддерживает любой уровень вложенности JSON и явный синтаксис блоков. Он рендерит данные в память с последующим применением к листам Excel, корректно копируя стили и горизонтальные объединения (merge) по строкам-шаблонам.

### Поддерживаемый синтаксис

- Вставка значения: `{{= expr}}`
  - Примеры: `{{= .name}}`, `{{= $.company.title}}`, `{{= $i+1}}`
- Inline‑условие: `iif(cond, then, else)` внутри `{{= ...}}`
  - Примеры: `{{= iif($.flag, 'Да', 'Нет') }}`, `{{= iif(len($.arr)>1, 'MANY', 'ONE') }}`
- Цикл по массиву: `{{#each path as $item i=$i}} ... {{/each}}`
  - `path`: абсолютный (`$.departments`) или относительный (`.employees`)
  - `$item`: имя переменной текущего элемента (по умолчанию `$`)
  - `i=$i`: имя переменной индекса (опционально)
- Итерация по объекту (map): `{{#each-obj path as $k $v}} ... {{/each-obj}}`
- Условия: `{{#if expr}} ... {{else}} ... {{/if}}`
  - Примеры выражений: `exists(.field)`, `len(.arr) > 0`, `.status == "ok"`
- Функции в выражениях:
  - `len(x)` — длина массива/строки/объекта
  - `exists(x)` — проверка наличия значения по пути
  - `join(arrayPath, sep, [fieldPath])` — склейка массива, опционально по полю

- Индексированный доступ:
  - `path[index]` — индекс может быть числом или выражением/переменной из контекста блоков: `[$i]`, `[$k]`, `[$var]`.
  - Примеры: `{{= $.list[$i].name}}`, `{{= .rows[$ri]}}`

Правило: внутри `{{= ...}}` результат должен быть скаляром. Если путь ведет к массиву/объекту — используйте `{{#each}}` или `join()`.

Контекст:
- `.` — текущий элемент
- `$` или `$root` — корень JSON
- Переменные из циклов: например, `$item`, `$i`

### Якоря путей: $, ., переменные (с примерами)

- Что такое якоря:
  - `$.path` — абсолютный путь от корня (не зависит от текущего контекста).
  - `.path` — относительный путь от текущего элемента (контекст задаёт ближайший `each`/`each-obj`).
  - `$var.path` — путь от явно названной переменной, объявленной в `as $var` внешнего цикла.

- Когда что выбирать:
  - Используйте `$.…`, когда нужно надёжно обратиться к данным «из корня» из любой глубины (кросс-ссылки).
  - Используйте `.…` сразу после открытия блока, если обращаетесь к полям текущего элемента.
  - Используйте `$var.…` во вложенных блоках, чтобы однозначно ссылаться на элемент внешнего уровня и не зависеть от смены `.` внутри внутренних циклов.

- Эквивалентность внутри блока `each`:
  - Внутри `{{#each $.arr as $row}}` выражения `{{#each .items}}` и `{{#each $row.items}}` равнозначны, пока вы не сменили контекст ещё одним вложенным `each`.

#### Пример A: вложенные блоки с явной переменной

JSON:

```json
{
  "material_resources": {
    "sections": [
      {"title": "С1", "entries": [{"name": "A"}, {"name": "B"}]},
      {"title": "С2", "entries": []}
    ]
  }
}
```

Шаблон (фрагмент):

| A |
|---|
| {{#each $.material_resources.sections as $sec i=$si}} |
| Раздел {{= $si+1}}: {{= $sec.title}} |
| {{#each $sec.entries as $e i=$ei}} |
| - {{= $e.name}} |
| {{/each}} |
| {{/each}} |

Альтернатива: заменить `{{#each $sec.entries …}}` на `{{#each .entries …}}`, так как внутри внешнего `each` текущий элемент (`.`) равен `$sec`.

#### Пример B: кросс-ссылка на корень из вложенного блока

JSON:

```json
{
  "users": [{"name":"А"}, {"name":"Б"}],
  "report": {"date": "2025-08-06"}
}
```

Шаблон (фрагмент):

| A |
|---|
| {{#each $.users as $u}} |
| {{= $u.name}} ({{= $.report.date}}) |
| {{/each}} |

Результат: `А (2025-08-06)`, `Б (2025-08-06)` — дата читается через абсолютный путь `$.report.date` независимо от текущего `each`.

### Программный API

```go
// Базовый путь: pkg/excel

// Высокоуровневая функция (готовое решение):
func WriteResultsWithTemplate(templatePath, destPath string, outputs []string) error

// Низкоуровневый контроль:
tmpl, _ := excel.LoadTemplate(templatePath) // построение AST по листам
_ = tmpl.Render(outputs)                   // рендер в память (outputs — JSON-строки)
_ = tmpl.Save(destPath)                    // сохранение результата
```

`outputs` — срез JSON-строк (массивов/объектов). При рендере движок ищет нужные пути в каждом из переданных корней; первый найденный — используется.

---

### Примеры

#### 1) Простые подстановки

JSON:
```json
{
  "title": "Отчет",
  "date": "2025-08-06",
  "author": {"name": "Иван"}
}
```

Шаблон (лист Excel как таблица):

| A                 | B                 |
|-------------------|-------------------|
| Заголовок         | {{= $.title}}     |
| Дата              | {{= $.date}}      |
| Автор             | {{= $.author.name}} |

Результат:

| A         | B         |
|-----------|-----------|
| Заголовок | Отчет     |
| Дата      | 2025-08-06|
| Автор     | Иван      |

##### Скалярная подстановка из вложенного объекта (без циклов)

JSON:
```json
{
  "user": { "name": "nikita" }
}
```

Шаблон:

| A                | B                       |
|------------------|-------------------------|
| Имя пользователя | {{= $.user.name}}       |
| Приветствие      | Hello, {{= $.user.name}}!|
| Возраст          | {{= $.user.age}}        |

Результат:

| A                | B                |
|------------------|------------------|
| Имя пользователя | nikita           |
| Приветствие      | Hello, nikita!   |
| Возраст          |                  |

Пояснение:
- `{{= $.user.name}}` берёт значение по абсолютному пути от корня JSON.
- Если путь отсутствует (`$.user.age`), в ячейку записывается пустая строка.

##### Inline‑условия в ячейках одной строки

JSON:
```json
{
  "flag": true,
  "arr": [1,2]
}
```

Шаблон:

| A                               | B                                        | C                                  |
|---------------------------------|------------------------------------------|------------------------------------|
| {{= iif($.flag, 'ON','OFF') }}  | {{= iif(len($.arr) > 1, 'MANY','ONE') }} | {{= iif($.missing, 'YES','NO') }}  |

Результат:

| A   | B     | C  |
|-----|-------|----|
| ON  | MANY  | NO |

Замечания:
- `iif(cond, then, else)` вычисляется inline и позволяет иметь независимые условия в разных ячейках одной строки.
- `cond` — любое булево выражение, поддерживаемое движком (`len`, `exists`, сравнения, and/or/not).

---

#### 2) Перебор массива строк (таблица пользователей)

JSON:
```json
{
  "users": [
    {"name": "А", "age": 30},
    {"name": "Б", "age": 25}
  ]
}
```

Шаблон:

| A                                  | B                |
|------------------------------------|------------------|
| Имя                                | Возраст          |
| {{#each $.users as $u i=$i}}       |                  |
| {{= $u.name}}                      | {{= $u.age}}     |
| {{/each}}                          |                  |

Результат:

| A   | B       |
|-----|---------|
| Имя | Возраст |
| А   | 30      |
| Б   | 25      |

---

#### 3) Вложенные группы (проекты → вехи → задачи)

JSON:
```json
{
  "projects": [
    {
      "name": "P1",
      "milestones": [
        {"name": "M1", "tasks": [{"t": "T1"}, {"t": "T2"}]},
        {"name": "M2", "tasks": [{"t": "T3"}]}
      ]
    }
  ]
}
```

Шаблон:

| A                                                   |
|-----------------------------------------------------|
| {{#each $.projects as $p}}                           |
| Проект: {{= $p.name}} (вех: {{= len($p.milestones)}}) |
| {{#if len($p.milestones) > 0}}                       |
| {{#each $p.milestones as $m}}                        |
| Веха: {{= $m.name}} (задач: {{= len($m.tasks)}})     |
| {{#each $m.tasks as $t i=$ti}}                       |
| Задача {{= $ti+1}}: {{= $t.t}}                       |
| {{/each}}                                            |
| {{/each}}                                            |
| {{else}}                                             |
| Нет вех                                             |
| {{/if}}                                              |
| {{/each}}                                            |

Результат:

| A                                            |
|----------------------------------------------|
| Проект: P1 (вех: 2)                          |
| Веха: M1 (задач: 2)                          |
| Задача 1: T1                                 |
| Задача 2: T2                                 |
| Веха: M2 (задач: 1)                          |
| Задача 1: T3                                 |

---

#### 4) join с полем объекта

JSON:
```json
{
  "users": [
    {"name": "A", "phones": [{"n": "111"}, {"n": "222"}]},
    {"name": "B", "phones": [{"n": "333"}]}
  ]
}
```

Шаблон:

| A                                      |
|----------------------------------------|
| {{#each $.users as $u}}                |
| {{= $u.name}}: {{= join($u.phones, ", ", "n")}} |
| {{/each}}                              |

Результат:

| A           |
|-------------|
| A: 111, 222 |
| B: 333      |

---

#### 5) Итерация по объекту (map)

JSON:
```json
{
  "meta": {"version": "1.0", "owner": "dept"}
}
```

Шаблон:

| A                                        | B        |
|------------------------------------------|----------|
| Ключ                                     | Значение |
| {{#each-obj $.meta as $k $v}}            |          |
| {{= $k}}                                 | {{= $v}} |
| {{/each-obj}}                            |          |

Результат:

| A        | B        |
|----------|----------|
| owner    | dept     |
| version  | 1.0      |

---

#### 6) Условия и пустые массивы

JSON:
```json
{
  "team": { "name": "Core", "members": [] }
}
```

Шаблон:

| A                                                       |
|---------------------------------------------------------|
| Команда: {{= $.team.name}}                              |
| {{#if len($.team.members) > 0}}                         |
| Участники есть                                          |
| {{else}}                                                |
| Участников нет                                          |
| {{/if}}                                                 |

Результат:

| A              |
|----------------|
| Команда: Core  |
| Участников нет |

---

### Поведение при отсутствии данных

- **Вставки `{{= expr}}`**: если по пути нет значения, в ячейку записывается пустая строка (ячейка остаётся пустой).
- **`{{#each}}` по пустому/отсутствующему массиву**: тело блока не рендерится; шаблонная строка с выражениями удаляется; строки, содержащие только управляющие маркеры (`{{#each}}`, `{{/each}}`), удаляются.
- **`{{#if}}`**: при ложно оцениваемом выражении рендерится ветка `{{else}}` (если задана); строки с маркерами удаляются.
- **Статические строки** (без маркеров): сохраняются без изменений.
- **Единые правила для всех листов**: движок проходит каждый лист и применяет одинаковую логику: нет данных → нет плейсхолдеров в результате; служебные строки удаляются.

#### Примеры для сценариев без данных

1) Одиночная вставка без значения

Шаблон:

| A    | B                    |
|------|----------------------|
| Имя  | {{= $.user.name }}   |

Данные: `{"user":{}}`

Результат:

| A    | B    |
|------|------|
| Имя  |      |

2) Пустой each-блок

Шаблон:

| A                                |
|----------------------------------|
| Список                           |
| {{#each $.items as $it}}         |
| {{= $it.name}}                   |
| {{/each}}                        |

Данные: `{"items":[]}`

Результат:

| A        |
|----------|
| Список   |

3) Две таблицы, данные только для одной

Шаблон:

| A                                | B                 |
|----------------------------------|-------------------|
| Таблица A                        |                   |
| {{#each $.tableA as $row i=$i}}  |                   |
| {{= $i+1}}                       | {{= $row.name}}   |
| {{/each}}                        |                   |
| Таблица B                        |                   |
| {{#each $.tableB as $row i=$i}}  |                   |
| {{= $i+1}}                       | {{= $row.name}}   |
| {{/each}}                        |                   |

Данные: `{"tableA":[{"name":"A-1"},{"name":"A-2"}]}`

Результат:

| A          | B    |
|------------|------|
| Таблица A  |      |
| 1          | A-1  |
| 2          | A-2  |
| Таблица B  |      |

4) Несколько листов — данные только на одном

Лист `Sheet1` (шаблон):

| A    | B                  |
|------|--------------------|
| T1   | {{= $.a }}         |

Лист `Sheet2` (шаблон):

| A    | B                  |
|------|--------------------|
| T2   | {{= $.b }}         |

Данные: `{"a":"X"}`

Sheet1 (результат):

| A    | B  |
|------|----|
| T1   | X  |

Sheet2 (результат):

| A    | B  |
|------|----|
| T2   |    |

### Рекомендации по шаблонам Excel

- Размещайте маркеры-блоки (`{{#each}}`, `{{/each}}`, `{{#if}}`, `{{/if}}`) целиком в отдельных ячейках строки. Вся последовательность строк между `{{#each}}` и `{{/each}}` повторяется как группа.
- Строки, содержащие только управляющие маркеры (`{{#each}}`, `{{/each}}`, `{{#if}}`, `{{/if}}`, `{{else}}`), автоматически удаляются из итогового листа.
- Используйте относительные пути от текущего элемента (`.field`) внутри вложенных блоков.
- Для склеивания списков используйте `join()` вместо прямой вставки массива.
- Формулы и абсолютные адреса в Excel не переписываются; по возможности используйте относительные ссылки или именованные диапазоны.
- Горизонтальные объединения (merge), встречающиеся в образцовой строке, будут продублированы на каждой сгенерированной строке.

#### Несколько таблиц на одном листе (вертикально)

Когда на одном листе размещены несколько таблиц одна под другой (например, два `each`-блока на одинаковых столбцах, разделённые заголовком), движок рендерит их независимо и безопасно:

- Рендер для каждой таблицы «якорится» на её строке-шаблоне — это строка, где есть выражения `{{= ...}}`.
- Для каждого элемента массива движок вставляет новую строку непосредственно ПЕРЕД строкой-шаблоном, копирует стили и горизонтальные объединения из этой строки и записывает значения.
- После вставки исходная строка-шаблон удаляется. Любые СТАТИЧЕСКИЕ строки между таблицами (заголовки, пустые отступы, формулы) сохраняются и НЕ затираются.
- Строки, содержащие ТОЛЬКО управляющие маркеры (`{{#each}}`, `{{/each}}`, `{{#if}}`, `{{/if}}`, `{{else}}`), удаляются.

Требования и советы:
- Размещайте заголовок второй таблицы в отдельной статической строке между блоками `{{/each}}` первой и `{{#each}}` второй.
- Не смешивайте заголовки с управляющими маркерами в одной строке — такие строки будут удалены как маркерные.
- Вертикальные объединения ячеек не копируются автоматически; горизонтальные объединения образцовой строки дублируются для каждой сгенерированной строки.

Пример шаблона (фрагмент листа):

```
A1: Таблица A
A2: {{#each $.tableA as $row i=$i}}
A3: {{= $i+1}}   | B3: {{= $row.name}}
A4: {{/each}}

A6: Таблица B
A7: {{#each $.tableB as $row i=$i}}
A8: {{= $i+1}}   | B8: {{= $row.name}}
A9: {{/each}}
```

JSON:

```json
{
  "tableA": [{"name": "A-1"}, {"name": "A-2"}, ..., {"name": "A-10"}],
  "tableB": [{"name": "B-1"}, {"name": "B-2"}, ..., {"name": "B-10"}]
}
```

Результат: строки `A-1..A-10` идут сразу под "Таблица A"; заголовок "Таблица B" остаётся на месте, а данные `B-1..B-10` рендерятся НИЖЕ него. Таким образом, первая таблица не затирает вторую независимо от количества строк.

Правильно/неправильно:

```
// ✅ Правильно: заголовок между блоками — отдельная статическая строка
... {{/each}}
Таблица B
{{#each $.tableB as $row}}
...
{{/each}}

// ❌ Неправильно: заголовок в одной строке с маркером (строка будет удалена)
Таблица B {{#each $.tableB as $row}}
...
{{/each}}
```

### Пример с динамическим индексом

JSON:
```json
{
  "groups": [
    { "title": "G1", "rows": ["A", "B"] },
    { "title": "G2", "rows": ["X"] }
  ]
}
```

Шаблон:

| A                                         |
|-------------------------------------------|
| {{#each $.groups as $g i=$gi}}            |
| Заголовок {{= $gi+1}}: {{= $g.title}}     |
| {{#each $g.rows as $r i=$ri}}             |
| Элемент {{= $ri+1}}: {{= $g.rows[$ri]}}   |
| {{/each}}                                 |
| {{/each}}                                 |

Результат:

| A                          |
|----------------------------|
| Заголовок 1: G1            |
| Элемент 1: A               |
| Элемент 2: B               |
| Заголовок 2: G2            |
| Элемент 1: X               |

### Пример кода

```go
package main

import (
    "log"
    excel "github.com/your/module/pkg/excel"
)

func main() {
    templatePath := "templates/tech_map.xlsx"
    destPath := "results/out.xlsx"
    jsonData := `{"users":[{"name":"А","age":30},{"name":"Б","age":25}]}`

    if err := excel.WriteResultsWithTemplate(templatePath, destPath, []string{jsonData}); err != nil {
        log.Fatalf("failed: %v", err)
    }
}
```